# 计算机网络Chapter3

# 运输层

邮件：数据完整性

视频传输：吞吐量，准时，延迟

协议：TCP，UDP，IP

互联网：TCP/IP协议栈

服务

- 提供了logical communication
  - 不是物理上的通信，不关心中间结点
  - 从应用程序的角度来看，不同的主机好像直连一样
  - 就是将应用层的多个端口整合到一起，看成是一个主机
- app process
  - 实际上主机之间可能有多个进程相互通信
  - 可以认为多个通信进程，传输层负责将网络层的单个包分发

运输层中的分组：segment（报文段）

网络层中的分组：datagram（数据报）

在发送端，将消息分成多个部分

接收端，将这些部分整合到一起

在网络层中，我们只认为是一个通信进程

## multiplexing，demultiplexing

多路复用（multiplexing）

- 将多个包发送到网络层
- 用于发送方

多路分解（demultiplexing）

- 将一个包分成多个包，发放给不同的进程中
- 用于接收方

### demultiplexing

通过协议中不同的端口号，将数据段分发到不同的端口中

此过程不需要识别ip地址

#### connectionless multiplexing

UDP

通过一个二元组来全面标识的，即目的IP地址和目的端口号

如果两个数据包的源IP地址和端口号不同，这两个数据包也会进入同一个socket

只根据destination port number确定

源端口号作为返回地址

#### connection oriented multiplexing

TCP

使用四元组定义一个连接（发送端的ip地址，端口号，接收端的ip地址，端口号）

一个port number会有多个socket

服务器创建连接时，会自己创建一个welcome socket

当接收到客户端的连接请求时，创建一个客户端socket

这些socket中都存在一个port number中

通过这个四元组将数据包分解到socket中

## UDP

独立的处理segment，用于高准时性的应用程序

由于UDP是乱序的，在应用程序中我们需要自己排序

当发现某一个segment是错的，我们也需要处理

没有阻塞控制（可以通过非常快的速度往外发送包）

对于TCP，就一定会有一个流量控制

checksum：用于检测错误，将所有的16位bit加起来，得到和，将进位与最低位相加，取反码即可，如果最后剩下一个byte，就后面补0即可

检测的时候，将所有包16bit加起来，判断结果是否为全1，如果全部为1，代表包无错误

## 可靠的数据传输

TCP是基于不可靠的IP协议经过一系列调整，变得可靠的

输出传输取决于频道的不同

用FSM标识可靠数据传输的过程

rdt代表可靠的传输，udt代表不可靠的传输

在数据传输的过程中，我们都假设空中只存在一个通信的数据包

### rdt1.0

对于理想的状态（信道完全可靠），接收协议解析即可

![img](./Snipaste_2019-10-15_16-55-24.png)

[^Fig.1]: 

对于发送端，调用发送可靠数据`rdt_send(data)`时触发事件，并产生了该数据的分组`packet = make_pkt(data)`，并将分组发送到不可靠的信道中`udt_send(packet)`

对于接收端，收到了可靠的消息后`rdt_rcv(packet)`，就提取数据`extract(packet,data)`，并送到高层`deliver_data(data)`

### rdt2.0

这里假设分组中的bit可能受损，当分组中的bit受损时，接收端检测到受损，并发送消息NAK，否则发送消息ACK（我们这里假设ACK和NAK不会发生受损）

![img](./Snipaste_2019-10-15_17-08-00.png)

[^Fig.2]: 

对于发送端，发送一个消息后

进入等待ACK或者NAK的模式

- 如果收到了NAK`isNAL(revpkt)`就重新发送
- 如果收到了ACK就进入等待状态继续发送

对于接收端，先进行检测`corrupt(revpkt)`

- 检测失败发送NAK
- 检测成功发送ACK

### rdt2.1

此时考虑ACK或NAK受损，且包乱序

对于包乱序，解决的方法是将发送数据分组的序号（sequence number）放到该字段，接收方只需要检查序号即可血清收到的分组是否需要重传

由于我们这里假设空中只有一个包在传递，所以只需要用一个bit（0或者1）来表示序号即可

![img](./Snipaste_2019-10-15_17-29-34.png)

[^Fig.3]: 发送方

由于包会乱序，所以发送端的状态机只是添加了序号，状态数是原来的两倍，唯一的不同在于序号处理的方法不同

![img](./Snipaste_2019-10-15_17-32-37.png)

[^Fig.4]: 接收方

对于发送方

- 如果收到了乱序的确认包，就重新发送数据包
- 如果收到受损的分组，重新发送数据包
- 如果收到了乱序的NAK，就重新发送

对于接收方

- 如果收到了乱序的数据包，就发送ACK，使发送方过渡到下一个状态
- 如果收到了受损的数据包，就发送NAK
- 如果收到了正确的数据包，就进入下一阶段，并发送ACK

### rdt2.2

只是rdt2.1的一个优化

不需要两种NAK，实际上，发送ACK0和ACK1就可以代替NAK

![img](./Snipaste_2019-10-15_17-44-23.png)

[^Fig.5]: 

### 总结

检测是否有错误，如果有，重新发送请求

error detection

feedback（使用ACK，NAK进行回传）

ACK不会变成NAK，在检测过程中会通不过

如果包是对的，但不是需要的包：发送ACK，使得发送端跳转到另外一个状态

只要corrupt（发现不是需要的包），就会重新发一个包

## 丢包

如果过了很久仍没有收到包，重新发送（超时）

发送方加上了time out

接收方没变

当ACK0丢失时，重新发送，接收方发送的是ACK0，而不是ACK1

如果接收ACK的时间太久，已经TimeOut了，就会导致每一个包发送两遍，扔掉一半的包

### rdt3.0

![img](./Snipaste_2019-10-15_17-48-24.png)

[^Fig.6]: 

接收端同rdt2.2

- 添加了timeout机制
- 发送了第一次包之后，就开启了计时器
- 如果timeout，就重新发送包，并重新开始计时
- 当接收到对应的ACK后，停止计时